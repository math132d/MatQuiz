<template>
  <div class="quiz fill aligner aligner--col aligner--space">

    <div class="name container container--top px-2 aligner aligner--row aligner--space" >
      <span>{{ `${this.questionId+1} / ${this.quiz.questions.length}` }}</span>
      <span style="margin-left: 24px"> {{ this.quiz.title || _quiz_id }} </span>
    </div>

    <div v-if="isLoading || !isOk"><p>Loading</p></div>
    <transition v-else name="slide" mode="out-in">
      <result-container
        v-if="showResults"

        :quiz="quiz"
        :quizResponse="quizResponse"
      />
      <question-container
        v-else

        @verify-response="onVerifyResponse"

        ref="questionContainer"

        :key="questionId"
        :isDone="isDone"
        :question="currentQuestion"
        :questionId="questionId"
      />
    </transition>

    <div class="aligner aligner--row" style="padding: 8px;">

      <!-- Verifyes the question-->
      <button @click="verifyQuestion" @keydown.stop class="verifyer aligner button" :class="{'button-primary': isVerified!==0, 'button-warning': isVerified===0}" :disabled="isDone===true" style="margin-right: 16px;" >
        <div class="aligner aligner--col">
          <p class="primary" >VERIFY ANSWERS</p>
          <p class="secondary" ><strong> {{ attempts }} </strong> Attempts Remaining</p>
        </div>
        <i v-if="isVerified === -1" class="material-icons">done</i>
        <i v-else-if="isVerified === 0" class="material-icons">warning</i>
        <i v-else class="material-icons">done_all</i>
      </button>

      <!-- Goes to next question-->
      <button @click="nextQuestion" @keydown.stop class="aligner button" :class="{'button-primary': isVerified===1, 'button-secondary': isVerified!==1}" :disabled="isVerified===-1" >
        <i class="material-icons">arrow_forward</i>
      </button>

    </div>

  </div>
</template>

<script>
import QuestionContainer from '../containers/QuestionContainer'
import ResultContainer from '../containers/ResultContainer'

export default {
  props: [
    '_quiz_id'
  ],

  data: function () {
    return {
      quiz: {},
      quizResponse: [],
      questionId: 0,
      isLoading: true,
      isOk: true,

      isVerified: -1, // -1 Not yet modified, 0 Not all answers are correct, 1 All answers are correct
      startTime: null,
      attempts: 3,

      showResults: false,
      tmpResponse: undefined
    }
  },

  methods: {
    nextQuestion: function () {
      const questionResponse = { // response data to be stored for grading
        answers: this.tmpResponse, // Updated in "onVerifyResponse"
        remainingAttempts: this.attempts,
        time: Date.now() - this.startTime // Time spent on question
      }

      this.quizResponse[this.questionId] = questionResponse

      if (this.questionId < this.quiz.questions.length - 1) {
        this.questionId++
      } else {
        this.showResults = true
      }
    },

    verifyQuestion: function () {
      if (!this.isDone) {
        this.$refs.questionContainer.verifyInputs()
      }
    },

    initQuestion: function () {
      this.startTime = Date.now()
      this.isVerified = -1
      this.attempts = (this.currentQuestion.answers.length > 1) ? this.currentQuestion.answers.length : 2
      this.tmpResponse = undefined
    },

    fetchQuiz: async function () {
      const url = `questions/${this._quiz_id}.json`
      console.log(`Fetching quiz from: ${url}`)
      const response = await fetch(url)

      if (response.ok) {
        return response.json()
      } else {
        this.isOk = false
        console.error(`Response not OK. Fetching ${url} failed`)
      }
    },

    // EVENT RELATED FUNCTIONS

    onVerifyResponse: function (response) {
      if (response.questionValid) {
        document.activeElement.blur()
        this.isVerified = 1
      } else {
        this.attempts--
        this.isVerified = 0
      }

      this.tmpResponse = response.questionResponse
    },
    onKeyDown: function (event) {
      if (event.isComposing || event.keyCode === 229) { // Suggested best practise by Mozilla -> ignore strokes generated by composition
        return // https://www.fxsitecompat.dev/en-CA/docs/2018/keydown-and-keyup-events-are-now-fired-during-ime-composition/
      }

      if (event.key === 'Enter') {
        if (!this.isDone) {
          this.verifyQuestion()
        } else {
          this.nextQuestion()
        }
      }
    }

  },

  computed: {
    currentQuestion: function () {
      return this.quiz.questions[this.questionId]
    },
    isDone: function () {
      return this.isVerified === 1 || this.attempts <= 0
    }
  },

  watch: {
    questionId: function () {
      this.initQuestion()
    }
  },

  components: {
    QuestionContainer,
    ResultContainer
  },
  created: async function () {
    window.addEventListener('keydown', this.onKeyDown)

    this.quiz = await this.fetchQuiz()
    this.isLoading = false

    this.quizResponse = new Array(this.quiz.questions.length)
    this.initQuestion()
  },
  beforeDestroy: function () {
    window.removeEventListener('keydown', this.onKeyDown)
  }
}
</script>

<style lang="scss" scoped>
  .quiz {
    overflow: hidden;
  }

  .name {
    font-weight: 400;
  }

  .verifyer {
    margin-right: 16px;
  }

  .verifyer .aligner {
    align-items: flex-start;
    line-height: 1.1;
    margin: auto 8px;
  }

  .verifyer .primary {
    font-weight: 400;
    font-size: 1.5rem;
  }

  .verifyer .secondary {
    font-size: 0.875rem;
  }

  .verifyer .secondary strong{
    font-weight: 600;
  }

  .slide-enter-active, .slide-leave-active {
    opacity: 1;
  }

  .slide-enter-active {
    transition: all 0.25s ease-out;
  }

  .slide-leave-active {
    transition: all 0.25s ease-in;
  }

  .slide-enter {
    transform: translate(64px, 0);
    opacity: 0;
  }

  .slide-leave-to {
    transform: translate(-64px, 0);
    opacity: 0;
  }
</style>
